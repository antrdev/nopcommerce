/* tslint:disable */
/* eslint-disable */
/**
 * nopCommerce Web API Frontend
 * Official nopCommerce Web API for public store
 *
 * The version of the OpenAPI document: v1.05
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { CheckoutBillingAddressModelDto } from '../model';
// @ts-ignore
import { CheckoutBillingAddressModelDtoBaseModelDtoRequest } from '../model';
// @ts-ignore
import { CheckoutBillingAddressModelDtoEditAddressResponse } from '../model';
// @ts-ignore
import { CheckoutBillingAddressModelDtoNextStepResponse } from '../model';
// @ts-ignore
import { CheckoutCompletedModelDto } from '../model';
// @ts-ignore
import { CheckoutConfirmModelDto } from '../model';
// @ts-ignore
import { CheckoutConfirmModelDtoNextStepResponse } from '../model';
// @ts-ignore
import { CheckoutPaymentMethodModelDto } from '../model';
// @ts-ignore
import { CheckoutRedirectResponse } from '../model';
// @ts-ignore
import { CheckoutShippingAddressModelDtoBaseModelDtoRequest } from '../model';
// @ts-ignore
import { CheckoutShippingAddressModelDtoNextStepResponse } from '../model';
// @ts-ignore
import { CompletedResponse } from '../model';
// @ts-ignore
import { ConfirmOrderResponse } from '../model';
// @ts-ignore
import { GetAddressByIdResponse } from '../model';
// @ts-ignore
import { NewBillingAddressResponse } from '../model';
// @ts-ignore
import { NewShippingAddressResponse } from '../model';
// @ts-ignore
import { OnePageCheckoutModelDto } from '../model';
// @ts-ignore
import { PaymentInfoResponse } from '../model';
// @ts-ignore
import { ShippingAddressResponse } from '../model';
// @ts-ignore
import { ShippingMethodResponse } from '../model';
/**
 * CheckoutApi - axios parameter creator
 * @export
 */
export const CheckoutApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Prepare billing address model
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutBillingAddressPost: async (requestBody?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/BillingAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare checkout completed model
         * @param {number} [orderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutCompletedGet: async (orderId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/Completed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutConfirmOrderGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/ConfirmOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare confirm order model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutConfirmPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/Confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete edited address
         * @param {number} addressId Address identifier
         * @param {boolean} [opc] Is one page checkout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutDeleteEditAddressAddressIdDelete: async (addressId: number, opc?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('apiFrontendCheckoutDeleteEditAddressAddressIdDelete', 'addressId', addressId)
            const localVarPath = `/api-frontend/Checkout/DeleteEditAddress/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (opc !== undefined) {
                localVarQueryParameter['opc'] = opc;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enter payment Info
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutEnterPaymentInfoPost: async (requestBody?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/EnterPaymentInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get specified Address by addresId
         * @param {number} addressId Address identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutGetAddressByIdAddressIdGet: async (addressId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('apiFrontendCheckoutGetAddressByIdAddressIdGet', 'addressId', addressId)
            const localVarPath = `/api-frontend/Checkout/GetAddressById/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutIndexGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/Index`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary New billing address
         * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutNewBillingAddressPost: async (checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/NewBillingAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutBillingAddressModelDtoBaseModelDtoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary New shipping address
         * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutNewShippingAddressPost: async (checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/NewShippingAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutShippingAddressModelDtoBaseModelDtoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare one page checkout model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOnePageCheckoutGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/OnePageCheckout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complete redirection payment (OPC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcCompleteRedirectionPaymentPost: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/OpcCompleteRedirectionPayment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Confirm order (OPC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcConfirmOrderGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/OpcConfirmOrder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save billing (OPC)
         * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSaveBillingPost: async (checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/OpcSaveBilling`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutBillingAddressModelDtoBaseModelDtoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save payment info (OPC)
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSavePaymentInfoPost: async (requestBody?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/OpcSavePaymentInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save payment method (OPC)
         * @param {string} paymentMethod 
         * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSavePaymentMethodPost: async (paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethod' is not null or undefined
            assertParamExists('apiFrontendCheckoutOpcSavePaymentMethodPost', 'paymentMethod', paymentMethod)
            const localVarPath = `/api-frontend/Checkout/OpcSavePaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (paymentMethod !== undefined) {
                localVarQueryParameter['paymentMethod'] = paymentMethod;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutPaymentMethodModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save shipping method (OPC)
         * @param {string} shippingOption 
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSaveShippingMethodPost: async (shippingOption: string, requestBody?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingOption' is not null or undefined
            assertParamExists('apiFrontendCheckoutOpcSaveShippingMethodPost', 'shippingOption', shippingOption)
            const localVarPath = `/api-frontend/Checkout/OpcSaveShippingMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (shippingOption !== undefined) {
                localVarQueryParameter['shippingOption'] = shippingOption;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save shipping (OPC)
         * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSaveShippingPost: async (checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/OpcSaveShipping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutShippingAddressModelDtoBaseModelDtoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare payment info model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutPaymentInfoGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/PaymentInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare payment method model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutPaymentMethodGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/PaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save edited address
         * @param {boolean} opc 
         * @param {CheckoutBillingAddressModelDto} [checkoutBillingAddressModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSaveEditAddressPost: async (opc: boolean, checkoutBillingAddressModelDto?: CheckoutBillingAddressModelDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'opc' is not null or undefined
            assertParamExists('apiFrontendCheckoutSaveEditAddressPost', 'opc', opc)
            const localVarPath = `/api-frontend/Checkout/SaveEditAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (opc !== undefined) {
                localVarQueryParameter['opc'] = opc;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutBillingAddressModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select billing address
         * @param {number} addressId Address identifier
         * @param {boolean} [shipToSameAddress] A value indicating \&quot;Ship to the same address\&quot; option is enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectBillingAddressAddressIdGet: async (addressId: number, shipToSameAddress?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('apiFrontendCheckoutSelectBillingAddressAddressIdGet', 'addressId', addressId)
            const localVarPath = `/api-frontend/Checkout/SelectBillingAddress/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (shipToSameAddress !== undefined) {
                localVarQueryParameter['shipToSameAddress'] = shipToSameAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select payment method
         * @param {string} paymentMethod 
         * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectPaymentMethodPost: async (paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentMethod' is not null or undefined
            assertParamExists('apiFrontendCheckoutSelectPaymentMethodPost', 'paymentMethod', paymentMethod)
            const localVarPath = `/api-frontend/Checkout/SelectPaymentMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (paymentMethod !== undefined) {
                localVarQueryParameter['paymentMethod'] = paymentMethod;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutPaymentMethodModelDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select shipping address
         * @param {number} addressId Address identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectShippingAddressAddressIdGet: async (addressId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('apiFrontendCheckoutSelectShippingAddressAddressIdGet', 'addressId', addressId)
            const localVarPath = `/api-frontend/Checkout/SelectShippingAddress/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Select shipping method
         * @param {string} shippingOption 
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectShippingMethodPost: async (shippingOption: string, requestBody?: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shippingOption' is not null or undefined
            assertParamExists('apiFrontendCheckoutSelectShippingMethodPost', 'shippingOption', shippingOption)
            const localVarPath = `/api-frontend/Checkout/SelectShippingMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (shippingOption !== undefined) {
                localVarQueryParameter['shippingOption'] = shippingOption;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare shipping address model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutShippingAddressGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/ShippingAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Prepare shipping method model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutShippingMethodGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/Checkout/ShippingMethod`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutApi - functional programming interface
 * @export
 */
export const CheckoutApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Prepare billing address model
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutBillingAddressPost(requestBody?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutBillingAddressModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutBillingAddressPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare checkout completed model
         * @param {number} [orderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutCompletedGet(orderId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompletedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutCompletedGet(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirm order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutConfirmOrderGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfirmOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutConfirmOrderGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare confirm order model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutConfirmPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfirmModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutConfirmPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete edited address
         * @param {number} addressId Address identifier
         * @param {boolean} [opc] Is one page checkout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutDeleteEditAddressAddressIdDelete(addressId: number, opc?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutBillingAddressModelDtoEditAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutDeleteEditAddressAddressIdDelete(addressId, opc, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Enter payment Info
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutEnterPaymentInfoPost(requestBody?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfirmModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutEnterPaymentInfoPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get specified Address by addresId
         * @param {number} addressId Address identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutGetAddressByIdAddressIdGet(addressId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAddressByIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutGetAddressByIdAddressIdGet(addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutIndexGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutBillingAddressModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutIndexGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary New billing address
         * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutNewBillingAddressPost(checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewBillingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutNewBillingAddressPost(checkoutBillingAddressModelDtoBaseModelDtoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary New shipping address
         * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutNewShippingAddressPost(checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewShippingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutNewShippingAddressPost(checkoutShippingAddressModelDtoBaseModelDtoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare one page checkout model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOnePageCheckoutGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnePageCheckoutModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOnePageCheckoutGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Complete redirection payment (OPC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcCompleteRedirectionPaymentPost(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutCompletedModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcCompleteRedirectionPaymentPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Confirm order (OPC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcConfirmOrderGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfirmModelDtoNextStepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcConfirmOrderGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save billing (OPC)
         * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcSaveBillingPost(checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutBillingAddressModelDtoNextStepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcSaveBillingPost(checkoutBillingAddressModelDtoBaseModelDtoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save payment info (OPC)
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcSavePaymentInfoPost(requestBody?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfirmModelDtoNextStepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcSavePaymentInfoPost(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save payment method (OPC)
         * @param {string} paymentMethod 
         * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcSavePaymentMethodPost(paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutConfirmModelDtoNextStepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcSavePaymentMethodPost(paymentMethod, checkoutPaymentMethodModelDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save shipping method (OPC)
         * @param {string} shippingOption 
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcSaveShippingMethodPost(shippingOption: string, requestBody?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcSaveShippingMethodPost(shippingOption, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save shipping (OPC)
         * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutOpcSaveShippingPost(checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutShippingAddressModelDtoNextStepResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutOpcSaveShippingPost(checkoutShippingAddressModelDtoBaseModelDtoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare payment info model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutPaymentInfoGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutPaymentInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare payment method model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutPaymentMethodGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutPaymentMethodModelDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutPaymentMethodGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Save edited address
         * @param {boolean} opc 
         * @param {CheckoutBillingAddressModelDto} [checkoutBillingAddressModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutSaveEditAddressPost(opc: boolean, checkoutBillingAddressModelDto?: CheckoutBillingAddressModelDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutBillingAddressModelDtoEditAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutSaveEditAddressPost(opc, checkoutBillingAddressModelDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Select billing address
         * @param {number} addressId Address identifier
         * @param {boolean} [shipToSameAddress] A value indicating \&quot;Ship to the same address\&quot; option is enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutSelectBillingAddressAddressIdGet(addressId: number, shipToSameAddress?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutRedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutSelectBillingAddressAddressIdGet(addressId, shipToSameAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Select payment method
         * @param {string} paymentMethod 
         * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutSelectPaymentMethodPost(paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutRedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutSelectPaymentMethodPost(paymentMethod, checkoutPaymentMethodModelDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Select shipping address
         * @param {number} addressId Address identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutSelectShippingAddressAddressIdGet(addressId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutRedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutSelectShippingAddressAddressIdGet(addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Select shipping method
         * @param {string} shippingOption 
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutSelectShippingMethodPost(shippingOption: string, requestBody?: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckoutRedirectResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutSelectShippingMethodPost(shippingOption, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare shipping address model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutShippingAddressGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutShippingAddressGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Prepare shipping method model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendCheckoutShippingMethodGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShippingMethodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendCheckoutShippingMethodGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CheckoutApi - factory interface
 * @export
 */
export const CheckoutApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutApiFp(configuration)
    return {
        /**
         * 
         * @summary Prepare billing address model
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutBillingAddressPost(requestBody?: { [key: string]: string; }, options?: any): AxiosPromise<CheckoutBillingAddressModelDto> {
            return localVarFp.apiFrontendCheckoutBillingAddressPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare checkout completed model
         * @param {number} [orderId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutCompletedGet(orderId?: number, options?: any): AxiosPromise<CompletedResponse> {
            return localVarFp.apiFrontendCheckoutCompletedGet(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutConfirmOrderGet(options?: any): AxiosPromise<ConfirmOrderResponse> {
            return localVarFp.apiFrontendCheckoutConfirmOrderGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare confirm order model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutConfirmPost(options?: any): AxiosPromise<CheckoutConfirmModelDto> {
            return localVarFp.apiFrontendCheckoutConfirmPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete edited address
         * @param {number} addressId Address identifier
         * @param {boolean} [opc] Is one page checkout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutDeleteEditAddressAddressIdDelete(addressId: number, opc?: boolean, options?: any): AxiosPromise<CheckoutBillingAddressModelDtoEditAddressResponse> {
            return localVarFp.apiFrontendCheckoutDeleteEditAddressAddressIdDelete(addressId, opc, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Enter payment Info
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutEnterPaymentInfoPost(requestBody?: { [key: string]: string; }, options?: any): AxiosPromise<CheckoutConfirmModelDto> {
            return localVarFp.apiFrontendCheckoutEnterPaymentInfoPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get specified Address by addresId
         * @param {number} addressId Address identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutGetAddressByIdAddressIdGet(addressId: number, options?: any): AxiosPromise<GetAddressByIdResponse> {
            return localVarFp.apiFrontendCheckoutGetAddressByIdAddressIdGet(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutIndexGet(options?: any): AxiosPromise<CheckoutBillingAddressModelDto> {
            return localVarFp.apiFrontendCheckoutIndexGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary New billing address
         * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutNewBillingAddressPost(checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options?: any): AxiosPromise<NewBillingAddressResponse> {
            return localVarFp.apiFrontendCheckoutNewBillingAddressPost(checkoutBillingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary New shipping address
         * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutNewShippingAddressPost(checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options?: any): AxiosPromise<NewShippingAddressResponse> {
            return localVarFp.apiFrontendCheckoutNewShippingAddressPost(checkoutShippingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare one page checkout model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOnePageCheckoutGet(options?: any): AxiosPromise<OnePageCheckoutModelDto> {
            return localVarFp.apiFrontendCheckoutOnePageCheckoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complete redirection payment (OPC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcCompleteRedirectionPaymentPost(options?: any): AxiosPromise<CheckoutCompletedModelDto> {
            return localVarFp.apiFrontendCheckoutOpcCompleteRedirectionPaymentPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Confirm order (OPC)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcConfirmOrderGet(options?: any): AxiosPromise<CheckoutConfirmModelDtoNextStepResponse> {
            return localVarFp.apiFrontendCheckoutOpcConfirmOrderGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save billing (OPC)
         * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSaveBillingPost(checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options?: any): AxiosPromise<CheckoutBillingAddressModelDtoNextStepResponse> {
            return localVarFp.apiFrontendCheckoutOpcSaveBillingPost(checkoutBillingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save payment info (OPC)
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSavePaymentInfoPost(requestBody?: { [key: string]: string; }, options?: any): AxiosPromise<CheckoutConfirmModelDtoNextStepResponse> {
            return localVarFp.apiFrontendCheckoutOpcSavePaymentInfoPost(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save payment method (OPC)
         * @param {string} paymentMethod 
         * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSavePaymentMethodPost(paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options?: any): AxiosPromise<CheckoutConfirmModelDtoNextStepResponse> {
            return localVarFp.apiFrontendCheckoutOpcSavePaymentMethodPost(paymentMethod, checkoutPaymentMethodModelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save shipping method (OPC)
         * @param {string} shippingOption 
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSaveShippingMethodPost(shippingOption: string, requestBody?: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return localVarFp.apiFrontendCheckoutOpcSaveShippingMethodPost(shippingOption, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save shipping (OPC)
         * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutOpcSaveShippingPost(checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options?: any): AxiosPromise<CheckoutShippingAddressModelDtoNextStepResponse> {
            return localVarFp.apiFrontendCheckoutOpcSaveShippingPost(checkoutShippingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare payment info model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutPaymentInfoGet(options?: any): AxiosPromise<PaymentInfoResponse> {
            return localVarFp.apiFrontendCheckoutPaymentInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare payment method model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutPaymentMethodGet(options?: any): AxiosPromise<CheckoutPaymentMethodModelDto> {
            return localVarFp.apiFrontendCheckoutPaymentMethodGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save edited address
         * @param {boolean} opc 
         * @param {CheckoutBillingAddressModelDto} [checkoutBillingAddressModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSaveEditAddressPost(opc: boolean, checkoutBillingAddressModelDto?: CheckoutBillingAddressModelDto, options?: any): AxiosPromise<CheckoutBillingAddressModelDtoEditAddressResponse> {
            return localVarFp.apiFrontendCheckoutSaveEditAddressPost(opc, checkoutBillingAddressModelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select billing address
         * @param {number} addressId Address identifier
         * @param {boolean} [shipToSameAddress] A value indicating \&quot;Ship to the same address\&quot; option is enabled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectBillingAddressAddressIdGet(addressId: number, shipToSameAddress?: boolean, options?: any): AxiosPromise<CheckoutRedirectResponse> {
            return localVarFp.apiFrontendCheckoutSelectBillingAddressAddressIdGet(addressId, shipToSameAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select payment method
         * @param {string} paymentMethod 
         * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectPaymentMethodPost(paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options?: any): AxiosPromise<CheckoutRedirectResponse> {
            return localVarFp.apiFrontendCheckoutSelectPaymentMethodPost(paymentMethod, checkoutPaymentMethodModelDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select shipping address
         * @param {number} addressId Address identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectShippingAddressAddressIdGet(addressId: number, options?: any): AxiosPromise<CheckoutRedirectResponse> {
            return localVarFp.apiFrontendCheckoutSelectShippingAddressAddressIdGet(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Select shipping method
         * @param {string} shippingOption 
         * @param {{ [key: string]: string; }} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutSelectShippingMethodPost(shippingOption: string, requestBody?: { [key: string]: string; }, options?: any): AxiosPromise<CheckoutRedirectResponse> {
            return localVarFp.apiFrontendCheckoutSelectShippingMethodPost(shippingOption, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare shipping address model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutShippingAddressGet(options?: any): AxiosPromise<ShippingAddressResponse> {
            return localVarFp.apiFrontendCheckoutShippingAddressGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Prepare shipping method model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendCheckoutShippingMethodGet(options?: any): AxiosPromise<ShippingMethodResponse> {
            return localVarFp.apiFrontendCheckoutShippingMethodGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutApi - object-oriented interface
 * @export
 * @class CheckoutApi
 * @extends {BaseAPI}
 */
export class CheckoutApi extends BaseAPI {
    /**
     * 
     * @summary Prepare billing address model
     * @param {{ [key: string]: string; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutBillingAddressPost(requestBody?: { [key: string]: string; }, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutBillingAddressPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare checkout completed model
     * @param {number} [orderId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutCompletedGet(orderId?: number, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutCompletedGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutConfirmOrderGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutConfirmOrderGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare confirm order model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutConfirmPost(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutConfirmPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete edited address
     * @param {number} addressId Address identifier
     * @param {boolean} [opc] Is one page checkout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutDeleteEditAddressAddressIdDelete(addressId: number, opc?: boolean, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutDeleteEditAddressAddressIdDelete(addressId, opc, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Enter payment Info
     * @param {{ [key: string]: string; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutEnterPaymentInfoPost(requestBody?: { [key: string]: string; }, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutEnterPaymentInfoPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get specified Address by addresId
     * @param {number} addressId Address identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutGetAddressByIdAddressIdGet(addressId: number, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutGetAddressByIdAddressIdGet(addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutIndexGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutIndexGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary New billing address
     * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutNewBillingAddressPost(checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutNewBillingAddressPost(checkoutBillingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary New shipping address
     * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutNewShippingAddressPost(checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutNewShippingAddressPost(checkoutShippingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare one page checkout model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOnePageCheckoutGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOnePageCheckoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complete redirection payment (OPC)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcCompleteRedirectionPaymentPost(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcCompleteRedirectionPaymentPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Confirm order (OPC)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcConfirmOrderGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcConfirmOrderGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save billing (OPC)
     * @param {CheckoutBillingAddressModelDtoBaseModelDtoRequest} [checkoutBillingAddressModelDtoBaseModelDtoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcSaveBillingPost(checkoutBillingAddressModelDtoBaseModelDtoRequest?: CheckoutBillingAddressModelDtoBaseModelDtoRequest, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcSaveBillingPost(checkoutBillingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save payment info (OPC)
     * @param {{ [key: string]: string; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcSavePaymentInfoPost(requestBody?: { [key: string]: string; }, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcSavePaymentInfoPost(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save payment method (OPC)
     * @param {string} paymentMethod 
     * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcSavePaymentMethodPost(paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcSavePaymentMethodPost(paymentMethod, checkoutPaymentMethodModelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save shipping method (OPC)
     * @param {string} shippingOption 
     * @param {{ [key: string]: string; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcSaveShippingMethodPost(shippingOption: string, requestBody?: { [key: string]: string; }, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcSaveShippingMethodPost(shippingOption, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save shipping (OPC)
     * @param {CheckoutShippingAddressModelDtoBaseModelDtoRequest} [checkoutShippingAddressModelDtoBaseModelDtoRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutOpcSaveShippingPost(checkoutShippingAddressModelDtoBaseModelDtoRequest?: CheckoutShippingAddressModelDtoBaseModelDtoRequest, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutOpcSaveShippingPost(checkoutShippingAddressModelDtoBaseModelDtoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare payment info model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutPaymentInfoGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutPaymentInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare payment method model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutPaymentMethodGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutPaymentMethodGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save edited address
     * @param {boolean} opc 
     * @param {CheckoutBillingAddressModelDto} [checkoutBillingAddressModelDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutSaveEditAddressPost(opc: boolean, checkoutBillingAddressModelDto?: CheckoutBillingAddressModelDto, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutSaveEditAddressPost(opc, checkoutBillingAddressModelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select billing address
     * @param {number} addressId Address identifier
     * @param {boolean} [shipToSameAddress] A value indicating \&quot;Ship to the same address\&quot; option is enabled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutSelectBillingAddressAddressIdGet(addressId: number, shipToSameAddress?: boolean, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutSelectBillingAddressAddressIdGet(addressId, shipToSameAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select payment method
     * @param {string} paymentMethod 
     * @param {CheckoutPaymentMethodModelDto} [checkoutPaymentMethodModelDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutSelectPaymentMethodPost(paymentMethod: string, checkoutPaymentMethodModelDto?: CheckoutPaymentMethodModelDto, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutSelectPaymentMethodPost(paymentMethod, checkoutPaymentMethodModelDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select shipping address
     * @param {number} addressId Address identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutSelectShippingAddressAddressIdGet(addressId: number, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutSelectShippingAddressAddressIdGet(addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Select shipping method
     * @param {string} shippingOption 
     * @param {{ [key: string]: string; }} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutSelectShippingMethodPost(shippingOption: string, requestBody?: { [key: string]: string; }, options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutSelectShippingMethodPost(shippingOption, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare shipping address model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutShippingAddressGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutShippingAddressGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Prepare shipping method model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutApi
     */
    public apiFrontendCheckoutShippingMethodGet(options?: any) {
        return CheckoutApiFp(this.configuration).apiFrontendCheckoutShippingMethodGet(options).then((request) => request(this.axios, this.basePath));
    }
}
