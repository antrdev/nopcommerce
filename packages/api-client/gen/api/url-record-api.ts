/* tslint:disable */
/* eslint-disable */
/**
 * nopCommerce Web API Frontend
 * Official nopCommerce Web API for public store
 *
 * The version of the OpenAPI document: v1.05
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { UrlRecordDto } from '../model';
// @ts-ignore
import { UrlRecordUrlRecordDtoPagedListDto } from '../model';
/**
 * UrlRecordApi - axios parameter creator
 * @export
 */
export const UrlRecordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Find slug
         * @param {number} entityId Entity identifier
         * @param {string} entityName Entity name
         * @param {number} languageId Language identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet: async (entityId: number, entityName: string, languageId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet', 'entityId', entityId)
            // verify required parameter 'entityName' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet', 'entityName', entityName)
            // verify required parameter 'languageId' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet', 'languageId', languageId)
            const localVarPath = `/api-frontend/UrlRecord/GetActiveSlug/{entityId}/{languageId}`
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)))
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (entityName !== undefined) {
                localVarQueryParameter['entityName'] = entityName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all URL records
         * @param {string} [slug] Slug
         * @param {number} [languageId] Language ID; \&quot;null\&quot; to load records with any language; \&quot;0\&quot; to load records with standard language only; otherwise to load records with specify language ID only
         * @param {boolean} [isActive] A value indicating whether to get active records; \&quot;null\&quot; to load all records; \&quot;false\&quot; to load only inactive records; \&quot;true\&quot; to load only active records
         * @param {number} [pageIndex] Page index
         * @param {number} [pageSize] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetAllGet: async (slug?: string, languageId?: number, isActive?: boolean, pageIndex?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-frontend/UrlRecord/GetAll`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['languageId'] = languageId;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['isActive'] = isActive;
            }

            if (pageIndex !== undefined) {
                localVarQueryParameter['pageIndex'] = pageIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an URL records by identifiers
         * @param {string} ids Array of URL record identifiers (separator - ;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetByIdsIdsGet: async (ids: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetByIdsIdsGet', 'ids', ids)
            const localVarPath = `/api-frontend/UrlRecord/GetByIds/{ids}`
                .replace(`{${"ids"}}`, encodeURIComponent(String(ids)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a URL record by slug
         * @param {string} slug Slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetBySlugGet: async (slug: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetBySlugGet', 'slug', slug)
            const localVarPath = `/api-frontend/UrlRecord/GetBySlug`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get search engine friendly name (slug)
         * @param {number} entityId Entity identifier
         * @param {string} entityName Entity name
         * @param {number} [languageId] Language identifier; pass null to use the current language
         * @param {boolean} [returnDefaultValue] A value indicating whether to return default value (if language specified one is not found)
         * @param {boolean} [ensureTwoPublishedLanguages] A value indicating whether to ensure that we have at least two published languages; otherwise, load only default value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetSeNameEntityIdGet: async (entityId: number, entityName: string, languageId?: number, returnDefaultValue?: boolean, ensureTwoPublishedLanguages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetSeNameEntityIdGet', 'entityId', entityId)
            // verify required parameter 'entityName' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetSeNameEntityIdGet', 'entityName', entityName)
            const localVarPath = `/api-frontend/UrlRecord/GetSeName/{entityId}`
                .replace(`{${"entityId"}}`, encodeURIComponent(String(entityId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (entityName !== undefined) {
                localVarQueryParameter['entityName'] = entityName;
            }

            if (languageId !== undefined) {
                localVarQueryParameter['languageId'] = languageId;
            }

            if (returnDefaultValue !== undefined) {
                localVarQueryParameter['returnDefaultValue'] = returnDefaultValue;
            }

            if (ensureTwoPublishedLanguages !== undefined) {
                localVarQueryParameter['ensureTwoPublishedLanguages'] = ensureTwoPublishedLanguages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get SE name
         * @param {string} name Name
         * @param {boolean} convertNonWesternChars A value indicating whether non western chars should be converted
         * @param {boolean} allowUnicodeCharsInUrls A value indicating whether Unicode chars are allowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetSeNameGet: async (name: string, convertNonWesternChars: boolean, allowUnicodeCharsInUrls: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetSeNameGet', 'name', name)
            // verify required parameter 'convertNonWesternChars' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetSeNameGet', 'convertNonWesternChars', convertNonWesternChars)
            // verify required parameter 'allowUnicodeCharsInUrls' is not null or undefined
            assertParamExists('apiFrontendUrlRecordGetSeNameGet', 'allowUnicodeCharsInUrls', allowUnicodeCharsInUrls)
            const localVarPath = `/api-frontend/UrlRecord/GetSeName`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (convertNonWesternChars !== undefined) {
                localVarQueryParameter['convertNonWesternChars'] = convertNonWesternChars;
            }

            if (allowUnicodeCharsInUrls !== undefined) {
                localVarQueryParameter['allowUnicodeCharsInUrls'] = allowUnicodeCharsInUrls;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate search engine name
         * @param {string} entityName Entity name
         * @param {string} seName Search engine name to validate
         * @param {string} name User-friendly name used to generate sename
         * @param {boolean} ensureNotEmpty Ensure that sename is not empty
         * @param {number} [entityId] Entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordValidateSeNameEntityIdPost: async (entityName: string, seName: string, name: string, ensureNotEmpty: boolean, entityId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'entityName' is not null or undefined
            assertParamExists('apiFrontendUrlRecordValidateSeNameEntityIdPost', 'entityName', entityName)
            // verify required parameter 'seName' is not null or undefined
            assertParamExists('apiFrontendUrlRecordValidateSeNameEntityIdPost', 'seName', seName)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiFrontendUrlRecordValidateSeNameEntityIdPost', 'name', name)
            // verify required parameter 'ensureNotEmpty' is not null or undefined
            assertParamExists('apiFrontendUrlRecordValidateSeNameEntityIdPost', 'ensureNotEmpty', ensureNotEmpty)
            const localVarPath = `/api-frontend/UrlRecord/ValidateSeName/entityId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (entityId !== undefined) {
                localVarQueryParameter['entityId'] = entityId;
            }

            if (entityName !== undefined) {
                localVarQueryParameter['entityName'] = entityName;
            }

            if (seName !== undefined) {
                localVarQueryParameter['seName'] = seName;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ensureNotEmpty !== undefined) {
                localVarQueryParameter['ensureNotEmpty'] = ensureNotEmpty;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UrlRecordApi - functional programming interface
 * @export
 */
export const UrlRecordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UrlRecordApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Find slug
         * @param {number} entityId Entity identifier
         * @param {string} entityName Entity name
         * @param {number} languageId Language identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet(entityId: number, entityName: string, languageId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet(entityId, entityName, languageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all URL records
         * @param {string} [slug] Slug
         * @param {number} [languageId] Language ID; \&quot;null\&quot; to load records with any language; \&quot;0\&quot; to load records with standard language only; otherwise to load records with specify language ID only
         * @param {boolean} [isActive] A value indicating whether to get active records; \&quot;null\&quot; to load all records; \&quot;false\&quot; to load only inactive records; \&quot;true\&quot; to load only active records
         * @param {number} [pageIndex] Page index
         * @param {number} [pageSize] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordGetAllGet(slug?: string, languageId?: number, isActive?: boolean, pageIndex?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UrlRecordUrlRecordDtoPagedListDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordGetAllGet(slug, languageId, isActive, pageIndex, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets an URL records by identifiers
         * @param {string} ids Array of URL record identifiers (separator - ;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordGetByIdsIdsGet(ids: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UrlRecordDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordGetByIdsIdsGet(ids, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets a URL record by slug
         * @param {string} slug Slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordGetBySlugGet(slug: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UrlRecordDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordGetBySlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get search engine friendly name (slug)
         * @param {number} entityId Entity identifier
         * @param {string} entityName Entity name
         * @param {number} [languageId] Language identifier; pass null to use the current language
         * @param {boolean} [returnDefaultValue] A value indicating whether to return default value (if language specified one is not found)
         * @param {boolean} [ensureTwoPublishedLanguages] A value indicating whether to ensure that we have at least two published languages; otherwise, load only default value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordGetSeNameEntityIdGet(entityId: number, entityName: string, languageId?: number, returnDefaultValue?: boolean, ensureTwoPublishedLanguages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordGetSeNameEntityIdGet(entityId, entityName, languageId, returnDefaultValue, ensureTwoPublishedLanguages, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get SE name
         * @param {string} name Name
         * @param {boolean} convertNonWesternChars A value indicating whether non western chars should be converted
         * @param {boolean} allowUnicodeCharsInUrls A value indicating whether Unicode chars are allowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordGetSeNameGet(name: string, convertNonWesternChars: boolean, allowUnicodeCharsInUrls: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordGetSeNameGet(name, convertNonWesternChars, allowUnicodeCharsInUrls, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Validate search engine name
         * @param {string} entityName Entity name
         * @param {string} seName Search engine name to validate
         * @param {string} name User-friendly name used to generate sename
         * @param {boolean} ensureNotEmpty Ensure that sename is not empty
         * @param {number} [entityId] Entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFrontendUrlRecordValidateSeNameEntityIdPost(entityName: string, seName: string, name: string, ensureNotEmpty: boolean, entityId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFrontendUrlRecordValidateSeNameEntityIdPost(entityName, seName, name, ensureNotEmpty, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UrlRecordApi - factory interface
 * @export
 */
export const UrlRecordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UrlRecordApiFp(configuration)
    return {
        /**
         * 
         * @summary Find slug
         * @param {number} entityId Entity identifier
         * @param {string} entityName Entity name
         * @param {number} languageId Language identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet(entityId: number, entityName: string, languageId: number, options?: any): AxiosPromise<string> {
            return localVarFp.apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet(entityId, entityName, languageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all URL records
         * @param {string} [slug] Slug
         * @param {number} [languageId] Language ID; \&quot;null\&quot; to load records with any language; \&quot;0\&quot; to load records with standard language only; otherwise to load records with specify language ID only
         * @param {boolean} [isActive] A value indicating whether to get active records; \&quot;null\&quot; to load all records; \&quot;false\&quot; to load only inactive records; \&quot;true\&quot; to load only active records
         * @param {number} [pageIndex] Page index
         * @param {number} [pageSize] Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetAllGet(slug?: string, languageId?: number, isActive?: boolean, pageIndex?: number, pageSize?: number, options?: any): AxiosPromise<UrlRecordUrlRecordDtoPagedListDto> {
            return localVarFp.apiFrontendUrlRecordGetAllGet(slug, languageId, isActive, pageIndex, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an URL records by identifiers
         * @param {string} ids Array of URL record identifiers (separator - ;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetByIdsIdsGet(ids: string, options?: any): AxiosPromise<Array<UrlRecordDto>> {
            return localVarFp.apiFrontendUrlRecordGetByIdsIdsGet(ids, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets a URL record by slug
         * @param {string} slug Slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetBySlugGet(slug: string, options?: any): AxiosPromise<UrlRecordDto> {
            return localVarFp.apiFrontendUrlRecordGetBySlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get search engine friendly name (slug)
         * @param {number} entityId Entity identifier
         * @param {string} entityName Entity name
         * @param {number} [languageId] Language identifier; pass null to use the current language
         * @param {boolean} [returnDefaultValue] A value indicating whether to return default value (if language specified one is not found)
         * @param {boolean} [ensureTwoPublishedLanguages] A value indicating whether to ensure that we have at least two published languages; otherwise, load only default value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetSeNameEntityIdGet(entityId: number, entityName: string, languageId?: number, returnDefaultValue?: boolean, ensureTwoPublishedLanguages?: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.apiFrontendUrlRecordGetSeNameEntityIdGet(entityId, entityName, languageId, returnDefaultValue, ensureTwoPublishedLanguages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get SE name
         * @param {string} name Name
         * @param {boolean} convertNonWesternChars A value indicating whether non western chars should be converted
         * @param {boolean} allowUnicodeCharsInUrls A value indicating whether Unicode chars are allowed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordGetSeNameGet(name: string, convertNonWesternChars: boolean, allowUnicodeCharsInUrls: boolean, options?: any): AxiosPromise<string> {
            return localVarFp.apiFrontendUrlRecordGetSeNameGet(name, convertNonWesternChars, allowUnicodeCharsInUrls, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate search engine name
         * @param {string} entityName Entity name
         * @param {string} seName Search engine name to validate
         * @param {string} name User-friendly name used to generate sename
         * @param {boolean} ensureNotEmpty Ensure that sename is not empty
         * @param {number} [entityId] Entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFrontendUrlRecordValidateSeNameEntityIdPost(entityName: string, seName: string, name: string, ensureNotEmpty: boolean, entityId?: number, options?: any): AxiosPromise<string> {
            return localVarFp.apiFrontendUrlRecordValidateSeNameEntityIdPost(entityName, seName, name, ensureNotEmpty, entityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UrlRecordApi - object-oriented interface
 * @export
 * @class UrlRecordApi
 * @extends {BaseAPI}
 */
export class UrlRecordApi extends BaseAPI {
    /**
     * 
     * @summary Find slug
     * @param {number} entityId Entity identifier
     * @param {string} entityName Entity name
     * @param {number} languageId Language identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet(entityId: number, entityName: string, languageId: number, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordGetActiveSlugEntityIdLanguageIdGet(entityId, entityName, languageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all URL records
     * @param {string} [slug] Slug
     * @param {number} [languageId] Language ID; \&quot;null\&quot; to load records with any language; \&quot;0\&quot; to load records with standard language only; otherwise to load records with specify language ID only
     * @param {boolean} [isActive] A value indicating whether to get active records; \&quot;null\&quot; to load all records; \&quot;false\&quot; to load only inactive records; \&quot;true\&quot; to load only active records
     * @param {number} [pageIndex] Page index
     * @param {number} [pageSize] Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordGetAllGet(slug?: string, languageId?: number, isActive?: boolean, pageIndex?: number, pageSize?: number, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordGetAllGet(slug, languageId, isActive, pageIndex, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an URL records by identifiers
     * @param {string} ids Array of URL record identifiers (separator - ;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordGetByIdsIdsGet(ids: string, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordGetByIdsIdsGet(ids, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets a URL record by slug
     * @param {string} slug Slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordGetBySlugGet(slug: string, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordGetBySlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get search engine friendly name (slug)
     * @param {number} entityId Entity identifier
     * @param {string} entityName Entity name
     * @param {number} [languageId] Language identifier; pass null to use the current language
     * @param {boolean} [returnDefaultValue] A value indicating whether to return default value (if language specified one is not found)
     * @param {boolean} [ensureTwoPublishedLanguages] A value indicating whether to ensure that we have at least two published languages; otherwise, load only default value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordGetSeNameEntityIdGet(entityId: number, entityName: string, languageId?: number, returnDefaultValue?: boolean, ensureTwoPublishedLanguages?: boolean, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordGetSeNameEntityIdGet(entityId, entityName, languageId, returnDefaultValue, ensureTwoPublishedLanguages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get SE name
     * @param {string} name Name
     * @param {boolean} convertNonWesternChars A value indicating whether non western chars should be converted
     * @param {boolean} allowUnicodeCharsInUrls A value indicating whether Unicode chars are allowed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordGetSeNameGet(name: string, convertNonWesternChars: boolean, allowUnicodeCharsInUrls: boolean, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordGetSeNameGet(name, convertNonWesternChars, allowUnicodeCharsInUrls, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate search engine name
     * @param {string} entityName Entity name
     * @param {string} seName Search engine name to validate
     * @param {string} name User-friendly name used to generate sename
     * @param {boolean} ensureNotEmpty Ensure that sename is not empty
     * @param {number} [entityId] Entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UrlRecordApi
     */
    public apiFrontendUrlRecordValidateSeNameEntityIdPost(entityName: string, seName: string, name: string, ensureNotEmpty: boolean, entityId?: number, options?: any) {
        return UrlRecordApiFp(this.configuration).apiFrontendUrlRecordValidateSeNameEntityIdPost(entityName, seName, name, ensureNotEmpty, entityId, options).then((request) => request(this.axios, this.basePath));
    }
}
